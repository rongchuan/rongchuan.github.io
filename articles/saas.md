### 单体应用 vs 微服务

管控系统本身业务是比较复杂的，它需要兼备业务接入、在线服务管控、数据配置托管、索引服务管控等等功能，这么多模块如果放到一个应用里面会逐渐得增加迭代的成本，应用本身会变得复杂到没有人能完全了解，最终走向成为庞然大物不可维护的命运，另外单体应用不利于资源利用率最大化，比如计算密集型的模块和存储密集型的模块放在一个应用里面，选择硬件时就必须做出妥协。而微服务将各个模块做合理的划分，可以将系统的复杂度分散到各个模块，每个模块的复杂度是可控的，同时部署上也可以更灵活。

其实在之前的管控系统开发过程中，我们已经把管控的一些部件拆出去，但是还不够，集群的管理逻辑目前散落在autoweb和autoscheduler当中，而且autoweb作为展示层托管了太多业务逻辑。

### 模块划分：垂直划分 && 水平划分

把一个复杂系统拆分成多个微服务，业务层面的划分(水平划分)是不可避免的，比如管控系统将在线链路和离线链路显式地拆成两块微服务。但是单从业务来做划分是不够的，要同时考虑到以后不断出现的新语言、新架构、新技术，我们需要根据升级的代价考量服务切分(垂直划分)，比如前后端分离就是在语言层面分离出两个服务，前端架构升级时不用后台配合修改模板。出于这种考虑，在线服务链路被拆成流程服务和集群原子操作服务。

## 选型

### 语言选型背景

作为一个C++体系的团队，使用python作为第二语言做一些周边工作通常是首选。以往管理igraph的方式通常是一个机房对应一台物理机作为总控，总控机上有很多的python脚本程序被用来管理业务，比如获取集群状态、发送控制指令等。使用脚本语言的好处是显而易见的，非常适合快速的需求开发，脚本写完直接就可以运行，但同时随着机房的增多，缺点也越发突出，主要体现在两个方面：

* 脚本散落在各个地方，有的是常驻进程，有的是crontab触发，管理起来异常困难；
* 迁移困难，当总控机故障时，代码迁移非常麻烦，安装python的依赖库(比如zklib)是十分头疼的问题；

鉴于python项目上碰到的工程管理维护的痛点，借着这次架构统一的东风，我们决定用拥有丰富依赖库和集团强力支持的java重构管控系统。

### 通信协议 rpc vs REST

rpc性能更好，但是开发复杂度高，管控在通信上没有太高的性能要求，而REST更方便且灵活，REST本身只是一种与代码无关的接口协定，只要能完成接口功能，具体是用什么实现的不重要，这样就给其他语言的服务接入管控带来便利性。

### 技术框架选型

没有最好的架构只有最合适的架构。因此在选型之前我们需要明确xxx的产品形态，要以什么样的形式提供服务。xxx定位是以服务化的形式提供统一的服务和数据管理，意味着它是业务弱相关的，在实际的业务接入使用当中，必须有一层业务逻辑在xxx的服务基础上构建定制化的管理方式。我们设想搭建一套业务管控系统应该是一个部件组合的过程，由定义业务逻辑层的服务组件和Autoumars的基础组件组合成一套完整的系统，至于使用方式，用户可以选择使用Http API调用的方式，也可以加上定制的web或mobile app简化操作。

我们选择前后端分离的架构，前端只有获取数据时需要和后端打交道，这样一来前端组件可以随时抽离，xxx可以以纯接口的方式提供服务，同时前端可以方便地迁移成各种产品而后台不用做太多变化，比如可以是web单页应用，可以是桌面应用，也可以是mobile app。后端则践行微服务的架构，使用多个微服务组合的方式组装起一个完整的系统。

#### 后端选型：SpringBoot

对于大多数应用使用spring的集团来说，SpringBoot作为java开发微服务似乎不需要太多的理由，除了轻量级和方便地沿袭了spring操作习惯以外，spring boot作为践行Devops的框架也是非常好的，它内置tomcat，可以在配置文件中直接配置tomcat启动参数，真正做到了将运行时的维护集成到开发流程当中。

除了框架以外，其他的基本依赖库选择如下：

* ORM系统，Mybatis vs Spring Data JPA：选择Mybatis，Mybatis可以直接写sql，自由度和可控性高，sql优化对mybatis也是有效的，而jpa相比较而言开发效率更高，但是屏蔽了sql的细节；
* 模板系统，Velocity vs Thymeleaf：选择Thymeleaf，Thymeleaf对原生html语法支持更好。前端单页应用的入口页面渲染需要用到Thymeleaf，在这里做buc认证构造cookie并将用户信息返回前端，这一项之后会考虑去掉，登录模块放到前端做；
* url入口controller层，Spring MVC vs Jersey：选择Spring MVC，它和Jersey都支持REST webservice，只是后者的实现参照了java REST标准JAX-RS，而Spring MVC自成一派。考虑到除controller以外我们用到的都是spring框架的东西，而Spring MVC与spring框架天然契合。至于性能不是考量的标准，因为性能差异基本上在json的处理上，两者用的json转换框架都是别的开源组件。

后端对数据库的操作代码写起来比较繁琐，但是结构基本相同，我们沉淀了一个生成数据库mapper代码的工具。

#### 前端选型：React + React native

Autoumars在接igraph管控时对前端的定位是web + mobile，而能够做到学习一次在两端都可以开发的框架，据我所知只有react和vue，对应的移动端分别使用react native和weex。出于笔者个人熟悉程度的原因，我们选择React + React native的架构，样式组件框架使用蚂蚁开源的Ant Design，它有支持react和react native的版本，antd的示例非常全，上手很快。web端介绍见这里。

## 开发实践

### 职责划分，协作开发

微服务架构下，每个人负责一个单独的功能模块并以接口的形式提供服务，xxx的切换组件、回流组件、数据中心组件、服务中心组件，各有一个人负责，各个组件之间有相互调用的关系，这时候接口的协定就显得非常重要了。wiki上写API文档是一种比较低效的方案，如果我们写好代码框架能自动生成文档，那就最好不过，swagger就是这么干的，使用简单的描述，加上REST API的协定，基本上就能知道接口的功能了。

#### 接口协定

接口的功能定义是谁给出来的呢？按理来说应该是使用方提出的，因为使用方的思维是基于使用的方便性来考虑的，而实现者通常是基于结构化资源来设计REST接口的。所以通常应该是前端来定义接口功能，但是鉴于我们团队没有前端，开发方式通常是从后往前，后台接口就绪以后，再在前端把各个接口拿到的数据组织起来。这种方式其实是比较低效的，举个例子，我们需要多个资源项，做法通常是调用多次接口，前端组合返回的数据。要知道一次请求的发起和接收是很耗资源的，多次请求前端组装数据相比一次请求后端组装数据低效的多，这方面淘宝使用nodejs作为中间层合并请求(GraphQL的发力处)的优化方案是非常值得借鉴的。不过对于重头开始开发的项目来说多一层nodejs没有太大必要，提前设计好交互，请求组合资源的工作放到后端做同样能达到优化的效果。

### 服务网关统一入口

微服务最终要暴露出去给人访问，微服务之间也需要通信，这就需要一层服务网关作为所有微服务的入口。网关的前提是每个微服务都有独一无二的url前缀，用户调用指定的前缀可以唯一路由到一个微服务。服务网关屏蔽了后端微服务的复杂结构，使得外部系统看到的就是一个统一完整的服务。同时，作为请求的统一入口，服务网关还可以做权限管理、操作日志、限流等。

#### 路由

我们调研了Netflix的微服务解决方案，它提供一套完整的服务注册、服务路由、负载均衡方案，考虑到之后的运行时运维操作如扩缩容，渐进发布等等，使用Netflix的方案需要我们额外地开发运维功能，而使用集团的LVS作负载均衡可以省掉这些麻烦，配套的freedom发布、psp扩容都是现成可以用的，因此我们只选择zuul作为服务路由方案，至于服务注册就得我们自己做了。原生的zuul路由规则是写在启动配置里面的，无法动态管理，我们对zuul做了改造，将路由规则持久化到数据库当中，定时将数据库的路由规则同步到进程运行时上下文当中生效。

#### 权限管理

网关提供API和可视化两种形式的调用形式，对于API，用户需要申请一个6位的token并在每次调用时加在url param中，对于可视化调用，后端会通过cookie校验用户的登录信息，针对不同网络环境，我们定制了两套cookie校验登录模块，内网buc以及外网自定义登录。对于所有的非GET接口，网关会记录下操作日志。另外，网关层可以对请求做一些优化，我们碰到的一个case，在集群规模增大时，二层调度器返回的数据量有几十兆，这么大数据返回到前端非常慢，网关层对于这类接口开启压缩，时延会降低很多。

### 产品化

产品化大多数时候都是针对前端而言的，不过后端也有需要注意的，比如，在接口型服务中，异常信息最好一层层往上抛，接口调用方通过返回的错误就能知道原因，而不必查看日志，所以记录error日志同时最好将错误返回。

对于前端，我们总结了几点：

1、建立品牌，在所有产品跟用户产生联系的地方加上象征品牌的logo;

* 通知邮件logo：
![屏幕快照 2017-10-10 上午10.11.55.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/d9c7d329757b05ddf9db4b699d116e4c.png)
* 钉钉消息logo：
![屏幕快照 2017-10-10 上午10.07.18.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/c3a1ab7b331acc11221a8001e55ffb4b.png)

2、所有报错的地方附上解决方案；

大多数用户遇到错误信息第一反应就是找答疑，而实际上异常问题就那么几种，相应的解决方案组内同学也是轻车熟路，将解决方案直接放在错误信息的后面对于用户和答疑同学都有好处，事实上，开源产品很多错误都会附上一个解释的链接，让用户明白哪里不正常然后自助解决。

3、尽量缩短操作路径，在最常被使用的页面展示尽可能多的信息；

功能开发完成以后，某某功能在哪里开发者心知肚明，但是用户并不清楚，因此在用户最关心的页面将其他功能的链接附上，就不需要用户关心整个网站的结构分层，点过去看就好了，不要让用户找功能而是把功能送到用户面前。

4、操作介绍尽量不要写成文档给人看，最好在用到的地方加显式引导

作为可视化操作的页面最好不要有介绍文档，文档是给产品用的不是给页面用的，对于首次使用的用户，与其看文档，不如加上显式的引导，完成引导以后用户基本上就知道怎么做了。比如，新用户如何学习创建表：

![屏幕快照 2017-10-29 下午10.11.16.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/37e7dae1063f2d1a56001f41d8c294a1.png)

![屏幕快照 2017-10-29 下午10.11.27.png](http://ata2-img.cn-hangzhou.img-pub.aliyun-inc.com/b92ff922e7030552fce7e1fff6c69ce0.png)

## 微服务引入的复杂度

尽管微服务在复杂系统的敏捷开发上给我们带来了很好的改进，但同时微服务结构也引进了其他方面的复杂度。服务的数目增加导致多服务的运维管理变得困难，比如多服务的配置共享、部署集成以及测试。

### 配置管理

多个服务通常需要共享一些配置，比如服务本身的地址，数据库的配置等。我们正在开发一个基于db管理的统一配置中心，所有服务的启动配置从中获取。

### 集成测试困难

除了各个微服务的单元测试，我们还需要集成测试来保证最上层功能的正确性。我们使用python的集成测试框架，对于xxx而言，一个业务场景的测试case就是一串接口的调用，依赖于多个服务的正常服务，如果其中一环出问题了，而集成的同学又没有精力熟悉所有的服务的话，往往需要不同服务的开发同学一同排查。比起单体服务的测试，微服务的测试相对要更麻烦一些。

### 服务部署 && 持续集成

xxx目前的微服务数目也达到10+了，部署一套完整的系统相对而言还是比较费事的，我们使用ansible来编排整个系统的编译打包部署工作，依次拉起所有的微服务，最开始的时候都部署在一台物理机上，ansible的纵向服务管理优势明显，但是当我们有预发、日常、新加坡、中美俄四套环境之后，这种部署方式在服务可用性和迭代发布上的弱势凸显出来了，对于一个服务多套环境的横向管理，ansible显得略微力不从心。我们对单个微服务做了容器化改造，单服务做多机房多机部署，并接入aone pipeline管理四个环境的迭代发布。单服务的持续集成见下图：

最终整个系统的部署结构如下图：

aone在单应用多环境的横向管理上做的很好，但是对于有同环境多个应用的微服务结构而言，ansible的纵向管理方式比aone更好，咨询得知目前aone不会对微服务的架构专门设定方案，另外aone对应用的定义是比较重的，我们正在解决这个问题，期望是托管在hippo上，使用ansible + 一个轻量级应用平台来管理微服务结构系统。
